From ed2c8ab4fb23beada8fa971e7feee41ab76f2243 Mon Sep 17 00:00:00 2001
From: Martin Jansa <martin.jansa@lge.com>
Date: Mon, 25 Jan 2021 14:18:13 -0800
Subject: [PATCH] disable using subsurface subcompositor

Signed-off-by: Martin Jansa <Martin.Jansa@gmail.com>
---
 .../ext/wayland/gstwaylandsink.c              |   6 +-
 .../gst-plugins-bad/ext/wayland/wldisplay.c   |   3 +
 .../gst-plugins-bad/ext/wayland/wlwindow.c    | 105 ++++--------------
 .../gst-plugins-bad/ext/wayland/wlwindow.h    |   5 -
 4 files changed, 28 insertions(+), 91 deletions(-)

diff --git a/subprojects/gst-plugins-bad/ext/wayland/gstwaylandsink.c b/subprojects/gst-plugins-bad/ext/wayland/gstwaylandsink.c
index 06c52bfe59..9af522534d 100644
--- a/subprojects/gst-plugins-bad/ext/wayland/gstwaylandsink.c
+++ b/subprojects/gst-plugins-bad/ext/wayland/gstwaylandsink.c
@@ -1068,14 +1068,13 @@ gst_wayland_sink_begin_geometry_change (GstWaylandVideo * video)
   g_return_if_fail (sink != NULL);
 
   g_mutex_lock (&sink->render_lock);
-  if (!sink->window || !sink->window->area_subsurface) {
+  if (!sink->window) {
     g_mutex_unlock (&sink->render_lock);
     GST_INFO_OBJECT (sink,
         "begin_geometry_change called without window, ignoring");
     return;
   }
 
-  wl_subsurface_set_sync (sink->window->area_subsurface);
   g_mutex_unlock (&sink->render_lock);
 }
 
@@ -1086,14 +1085,13 @@ gst_wayland_sink_end_geometry_change (GstWaylandVideo * video)
   g_return_if_fail (sink != NULL);
 
   g_mutex_lock (&sink->render_lock);
-  if (!sink->window || !sink->window->area_subsurface) {
+  if (!sink->window) {
     g_mutex_unlock (&sink->render_lock);
     GST_INFO_OBJECT (sink,
         "end_geometry_change called without window, ignoring");
     return;
   }
 
-  wl_subsurface_set_desync (sink->window->area_subsurface);
   g_mutex_unlock (&sink->render_lock);
 }
 
diff --git a/subprojects/gst-plugins-bad/ext/wayland/wldisplay.c b/subprojects/gst-plugins-bad/ext/wayland/wldisplay.c
index f326091990..7ffba3470f 100644
--- a/subprojects/gst-plugins-bad/ext/wayland/wldisplay.c
+++ b/subprojects/gst-plugins-bad/ext/wayland/wldisplay.c
@@ -346,7 +346,10 @@ gst_wl_display_new_existing (struct wl_display * display,
   }
 
   VERIFY_INTERFACE_EXISTS (compositor, "wl_compositor");
+  /* don't use subcompositor interface, it's not supported on webos */
+#if 0
   VERIFY_INTERFACE_EXISTS (subcompositor, "wl_subcompositor");
+#endif
   VERIFY_INTERFACE_EXISTS (shm, "wl_shm");
 
 #undef VERIFY_INTERFACE_EXISTS
diff --git a/subprojects/gst-plugins-bad/ext/wayland/wlwindow.c b/subprojects/gst-plugins-bad/ext/wayland/wlwindow.c
index 66df0fce7b..44d1be0667 100644
--- a/subprojects/gst-plugins-bad/ext/wayland/wlwindow.c
+++ b/subprojects/gst-plugins-bad/ext/wayland/wlwindow.c
@@ -159,8 +159,11 @@ gst_wl_window_finalize (GObject * gobject)
 {
   GstWlWindow *self = GST_WL_WINDOW (gobject);
 
-  if (self->wl_shell_surface)
+  if (self->wl_shell_surface) {
     wl_shell_surface_destroy (self->wl_shell_surface);
+    wl_proxy_wrapper_destroy (self->video_surface_wrapper);
+    wl_surface_destroy (self->video_surface);
+  }
 
   if (self->xdg_toplevel)
     xdg_toplevel_destroy (self->xdg_toplevel);
@@ -170,26 +173,13 @@ gst_wl_window_finalize (GObject * gobject)
   if (self->video_viewport)
     wp_viewport_destroy (self->video_viewport);
 
-  wl_proxy_wrapper_destroy (self->video_surface_wrapper);
-  wl_subsurface_destroy (self->video_subsurface);
-  wl_surface_destroy (self->video_surface);
-
-  if (self->area_subsurface)
-    wl_subsurface_destroy (self->area_subsurface);
-
-  if (self->area_viewport)
-    wp_viewport_destroy (self->area_viewport);
-
-  wl_proxy_wrapper_destroy (self->area_surface_wrapper);
-  wl_surface_destroy (self->area_surface);
-
   g_clear_object (&self->display);
 
   G_OBJECT_CLASS (gst_wl_window_parent_class)->finalize (gobject);
 }
 
 static GstWlWindow *
-gst_wl_window_new_internal (GstWlDisplay * display, GMutex * render_lock)
+gst_wl_window_new_internal (GstWlDisplay * display, struct wl_surface * surface, GMutex * render_lock)
 {
   GstWlWindow *window;
   struct wl_region *region;
@@ -199,36 +189,19 @@ gst_wl_window_new_internal (GstWlDisplay * display, GMutex * render_lock)
   window->render_lock = render_lock;
   g_cond_init (&window->configure_cond);
 
-  window->area_surface = wl_compositor_create_surface (display->compositor);
-  window->video_surface = wl_compositor_create_surface (display->compositor);
+  window->video_surface = surface;
 
-  window->area_surface_wrapper = wl_proxy_create_wrapper (window->area_surface);
   window->video_surface_wrapper =
       wl_proxy_create_wrapper (window->video_surface);
 
-  wl_proxy_set_queue ((struct wl_proxy *) window->area_surface_wrapper,
-      display->queue);
   wl_proxy_set_queue ((struct wl_proxy *) window->video_surface_wrapper,
       display->queue);
 
-  /* embed video_surface in area_surface */
-  window->video_subsurface =
-      wl_subcompositor_get_subsurface (display->subcompositor,
-      window->video_surface, window->area_surface);
-  wl_subsurface_set_desync (window->video_subsurface);
-
   if (display->viewporter) {
-    window->area_viewport = wp_viewporter_get_viewport (display->viewporter,
-        window->area_surface);
     window->video_viewport = wp_viewporter_get_viewport (display->viewporter,
         window->video_surface);
   }
 
-  /* never accept input events on the video surface */
-  region = wl_compositor_create_region (display->compositor);
-  wl_surface_set_input_region (window->video_surface, region);
-  wl_region_destroy (region);
-
   return window;
 }
 
@@ -257,8 +230,10 @@ gst_wl_window_new_toplevel (GstWlDisplay * display, const GstVideoInfo * info,
     gboolean fullscreen, GMutex * render_lock)
 {
   GstWlWindow *window;
+  struct wl_surface *surface;
 
-  window = gst_wl_window_new_internal (display, render_lock);
+  surface = wl_compositor_create_surface (display->compositor);
+  window = gst_wl_window_new_internal (display, surface, render_lock);
 
   /* Check which protocol we will use (in order of preference) */
   if (display->xdg_wm_base) {
@@ -266,7 +241,7 @@ gst_wl_window_new_toplevel (GstWlDisplay * display, const GstVideoInfo * info,
 
     /* First create the XDG surface */
     window->xdg_surface = xdg_wm_base_get_xdg_surface (display->xdg_wm_base,
-        window->area_surface);
+        window->video_surface);
     if (!window->xdg_surface) {
       GST_ERROR ("Unable to get xdg_surface");
       goto error;
@@ -287,7 +262,7 @@ gst_wl_window_new_toplevel (GstWlDisplay * display, const GstVideoInfo * info,
 
     /* Finally, commit the xdg_surface state as toplevel */
     window->configured = FALSE;
-    wl_surface_commit (window->area_surface);
+    wl_surface_commit (window->video_surface);
     wl_display_flush (display->display);
 
     g_mutex_lock (&window->configure_mutex);
@@ -303,7 +278,7 @@ gst_wl_window_new_toplevel (GstWlDisplay * display, const GstVideoInfo * info,
   } else if (display->wl_shell) {
     /* go toplevel */
     window->wl_shell_surface = wl_shell_get_shell_surface (display->wl_shell,
-        window->area_surface);
+        window->video_surface);
     if (!window->wl_shell_surface) {
       GST_ERROR ("Unable to get wl_shell_surface");
       goto error;
@@ -314,7 +289,7 @@ gst_wl_window_new_toplevel (GstWlDisplay * display, const GstVideoInfo * info,
     gst_wl_window_ensure_fullscreen (window, fullscreen);
   } else if (display->fullscreen_shell) {
     zwp_fullscreen_shell_v1_present_surface (display->fullscreen_shell,
-        window->area_surface, ZWP_FULLSCREEN_SHELL_V1_PRESENT_METHOD_ZOOM,
+        window->video_surface, ZWP_FULLSCREEN_SHELL_V1_PRESENT_METHOD_ZOOM,
         NULL);
   } else {
     GST_ERROR ("Unable to use either wl_shell, xdg_wm_base or "
@@ -343,19 +318,8 @@ gst_wl_window_new_in_surface (GstWlDisplay * display,
     struct wl_surface * parent, GMutex * render_lock)
 {
   GstWlWindow *window;
-  struct wl_region *region;
-  window = gst_wl_window_new_internal (display, render_lock);
-
-  /* do not accept input events on the area surface when embedded */
-  region = wl_compositor_create_region (display->compositor);
-  wl_surface_set_input_region (window->area_surface, region);
-  wl_region_destroy (region);
-
-  /* embed in parent */
-  window->area_subsurface =
-      wl_subcompositor_get_subsurface (display->subcompositor,
-      window->area_surface, parent);
-  wl_subsurface_set_desync (window->area_subsurface);
+  /* Since webos does not support subsurface, use the parent surface as it is. */
+  window = gst_wl_window_new_internal (display, parent, render_lock);
 
   wl_surface_commit (parent);
 
@@ -409,8 +373,6 @@ gst_wl_window_resize_video_surface (GstWlWindow * window, gboolean commit)
     gst_video_sink_center_rect (src, dst, &res, FALSE);
   }
 
-  wl_subsurface_set_position (window->video_subsurface, res.x, res.y);
-
   if (commit)
     wl_surface_commit (window->video_surface_wrapper);
 
@@ -422,12 +384,6 @@ gst_wl_window_set_opaque (GstWlWindow * window, const GstVideoInfo * info)
 {
   struct wl_region *region;
 
-  /* Set area opaque */
-  region = wl_compositor_create_region (window->display->compositor);
-  wl_region_add (region, 0, 0, G_MAXINT32, G_MAXINT32);
-  wl_surface_set_opaque_region (window->area_surface, region);
-  wl_region_destroy (region);
-
   if (!GST_VIDEO_INFO_HAS_ALPHA (info)) {
     /* Set video opaque */
     region = wl_compositor_create_region (window->display->compositor);
@@ -446,7 +402,6 @@ gst_wl_window_render (GstWlWindow * window, GstWlBuffer * buffer,
         gst_util_uint64_scale_int_round (info->width, info->par_n, info->par_d);
     window->video_height = info->height;
 
-    wl_subsurface_set_sync (window->video_subsurface);
     gst_wl_window_resize_video_surface (window, FALSE);
     gst_wl_window_set_opaque (window, info);
   }
@@ -459,23 +414,12 @@ gst_wl_window_render (GstWlWindow * window, GstWlBuffer * buffer,
 
     if (!window->is_area_surface_mapped) {
       gst_wl_window_update_borders (window);
-      wl_surface_commit (window->area_surface_wrapper);
       window->is_area_surface_mapped = TRUE;
     }
   } else {
     /* clear both video and parent surfaces */
     wl_surface_attach (window->video_surface_wrapper, NULL, 0, 0);
     wl_surface_commit (window->video_surface_wrapper);
-    wl_surface_attach (window->area_surface_wrapper, NULL, 0, 0);
-    wl_surface_commit (window->area_surface_wrapper);
-    window->is_area_surface_mapped = FALSE;
-  }
-
-  if (G_UNLIKELY (info)) {
-    /* commit also the parent (area_surface) in order to change
-     * the position of the video_subsurface */
-    wl_surface_commit (window->area_surface_wrapper);
-    wl_subsurface_set_desync (window->video_subsurface);
   }
 
   wl_display_flush (window->display->display);
@@ -496,7 +440,7 @@ gst_wl_window_update_borders (GstWlWindow * window)
   GstAllocator *alloc;
 
   if (window->display->viewporter) {
-    wp_viewport_set_destination (window->area_viewport,
+    wp_viewport_set_destination (window->video_viewport,
         window->render_rectangle.w, window->render_rectangle.h);
 
     if (window->is_area_surface_mapped) {
@@ -527,8 +471,8 @@ gst_wl_window_update_borders (GstWlWindow * window)
       gst_wl_shm_memory_construct_wl_buffer (gst_buffer_peek_memory (buf, 0),
       window->display, &info);
   gwlbuf = gst_buffer_add_wl_buffer (buf, wlbuf, window->display);
-  gst_wl_buffer_attach (gwlbuf, window->area_surface_wrapper);
-  wl_surface_damage_buffer (window->area_surface_wrapper, 0, 0, G_MAXINT32,
+  gst_wl_buffer_attach (gwlbuf, window->video_surface_wrapper);
+  wl_surface_damage_buffer (window->video_surface_wrapper, 0, 0, G_MAXINT32,
       G_MAXINT32);
 
   /* at this point, the GstWlBuffer keeps the buffer
@@ -552,9 +496,9 @@ gst_wl_window_set_render_rectangle (GstWlWindow * window, gint x, gint y,
   window->render_rectangle.w = w;
   window->render_rectangle.h = h;
 
-  /* position the area inside the parent - needs a parent commit to apply */
-  if (window->area_subsurface)
-    wl_subsurface_set_position (window->area_subsurface, x, y);
+  /* change the size of the video */
+  if (window->video_viewport)
+    wp_viewport_set_destination (window->video_viewport, w, h);
 
   if (window->is_area_surface_mapped)
     gst_wl_window_update_borders (window);
@@ -563,12 +507,9 @@ gst_wl_window_set_render_rectangle (GstWlWindow * window, gint x, gint y,
     return;
 
   if (window->video_width != 0) {
-    wl_subsurface_set_sync (window->video_subsurface);
     gst_wl_window_resize_video_surface (window, TRUE);
   }
 
-  wl_surface_commit (window->area_surface_wrapper);
-
-  if (window->video_width != 0)
-    wl_subsurface_set_desync (window->video_subsurface);
+  wl_surface_damage (window->video_surface_wrapper, 0, 0, w, h);
+  wl_surface_commit (window->video_surface_wrapper);
 }
diff --git a/subprojects/gst-plugins-bad/ext/wayland/wlwindow.h b/subprojects/gst-plugins-bad/ext/wayland/wlwindow.h
index 303c336ddd..1b23226393 100644
--- a/subprojects/gst-plugins-bad/ext/wayland/wlwindow.h
+++ b/subprojects/gst-plugins-bad/ext/wayland/wlwindow.h
@@ -44,13 +44,8 @@ struct _GstWlWindow
   GMutex *render_lock;
 
   GstWlDisplay *display;
-  struct wl_surface *area_surface;
-  struct wl_surface *area_surface_wrapper;
-  struct wl_subsurface *area_subsurface;
-  struct wp_viewport *area_viewport;
   struct wl_surface *video_surface;
   struct wl_surface *video_surface_wrapper;
-  struct wl_subsurface *video_subsurface;
   struct wp_viewport *video_viewport;
   struct wl_shell_surface *wl_shell_surface;
   struct xdg_surface *xdg_surface;
