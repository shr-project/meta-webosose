From 057677fd46abc4b5ab027f5989e55725099e985a Mon Sep 17 00:00:00 2001
From: Christophe Chapuis <chris.chapuis@gmail.com>
Date: Sat, 25 Apr 2020 09:44:07 +0000
Subject: [PATCH] Fix build for nodejs 12

Signed-off-by: Christophe Chapuis <chris.chapuis@gmail.com>
---
 src/node_ls2.cpp         |  2 +-
 src/node_ls2_base.cpp    |  6 +++---
 src/node_ls2_base.h      |  2 +-
 src/node_ls2_call.cpp    |  6 +++---
 src/node_ls2_call.h      |  2 +-
 src/node_ls2_handle.cpp  | 24 ++++++++++++------------
 src/node_ls2_handle.h    | 12 ++++++------
 src/node_ls2_message.cpp | 10 +++++-----
 src/node_ls2_message.h   |  6 +++---
 src/node_ls2_utils.cpp   |  8 ++++----
 src/node_ls2_utils.h     | 12 ++++++------
 11 files changed, 45 insertions(+), 45 deletions(-)

diff --git a/src/node_ls2.cpp b/src/node_ls2.cpp
index 4faa3da..a9b1f71 100644
--- a/src/node_ls2.cpp
+++ b/src/node_ls2.cpp
@@ -241,7 +241,7 @@ static void check_cb(uv_check_t* w)
 
 static struct econtext default_context;
 
-void init(Handle<Object> target)
+void init(Local<Object> target)
 {
     HandleScope scope(Isolate::GetCurrent());
     gMainLoop = g_main_loop_new(NULL, true);
diff --git a/src/node_ls2_base.cpp b/src/node_ls2_base.cpp
index a71d916..d8f6d67 100644
--- a/src/node_ls2_base.cpp
+++ b/src/node_ls2_base.cpp
@@ -23,7 +23,7 @@
 using namespace node;
 using namespace v8;
 
-void LS2Base::EmitMessage(const Handle<String>& symbol, LSMessage *message)
+void LS2Base::EmitMessage(const Local<String>& symbol, LSMessage *message)
 {
     Local<Value> messageObject = LS2Message::NewFromMessage(message);
     
@@ -31,7 +31,7 @@ void LS2Base::EmitMessage(const Handle<String>& symbol, LSMessage *message)
     // LS2Message::NewFromMessage
     if (!messageObject.IsEmpty()) {
 
-      Handle<Value> argv[2] =
+      Local<Value> argv[2] =
       {
         symbol, // event name
         messageObject  // argument
@@ -41,7 +41,7 @@ void LS2Base::EmitMessage(const Handle<String>& symbol, LSMessage *message)
                    this->handle(),
                    static_cast<const char*>("emit"),
                    2,
-                   static_cast<v8::Handle<v8::Value>*>(argv));
+                   static_cast<v8::Local<v8::Value>*>(argv));
     } else {
         // We don't want to silently lose messages
         syslog(LOG_USER | LOG_CRIT, "%s: messageObject is empty", __PRETTY_FUNCTION__);
diff --git a/src/node_ls2_base.h b/src/node_ls2_base.h
index dccd4be..d1f5283 100644
--- a/src/node_ls2_base.h
+++ b/src/node_ls2_base.h
@@ -27,7 +27,7 @@ class LS2Base : public node::ObjectWrap {
 protected:
 	// Common routine called whenever a message arrives from the bus. Different symbols
 	// are used to differentiate requests, responses and cancelled subscriptions
-	void EmitMessage(const v8::Handle<v8::String>& symbol, LSMessage *message);
+	void EmitMessage(const v8::Local<v8::String>& symbol, LSMessage *message);
 };
 
 #endif
diff --git a/src/node_ls2_call.cpp b/src/node_ls2_call.cpp
index c2f3ea1..e7d966e 100644
--- a/src/node_ls2_call.cpp
+++ b/src/node_ls2_call.cpp
@@ -35,7 +35,7 @@ static Persistent<String> response_symbol;
 
 // Called during add-on initialization to add the "Call" template function
 // to the target object.
-void LS2Call::Initialize (Handle<Object> target)
+void LS2Call::Initialize (Local<Object> target)
 {
     v8::Isolate* isolate = v8::Isolate::GetCurrent();
     HandleScope scope(isolate);
@@ -53,7 +53,7 @@ void LS2Call::Initialize (Handle<Object> target)
 
     response_symbol.Reset(isolate, String::NewFromUtf8(isolate, "response"));
 
-    target->Set(String::NewFromUtf8(isolate, "Call"), t->GetFunction());
+    target->Set(String::NewFromUtf8(isolate, "Call"), t->GetFunction(isolate->GetCurrentContext()).ToLocalChecked());
 }
 
 // Used by LSHandle to create a "Call" object that wraps a particular
@@ -62,7 +62,7 @@ Local<Object> LS2Call::NewForCall()
 {
     v8::Isolate* isolate = v8::Isolate::GetCurrent();
     Local<FunctionTemplate> lCallTemplate = Local<FunctionTemplate>::New(isolate, gCallTemplate);
-    Local<Function> function = lCallTemplate->GetFunction();
+    Local<Function> function = lCallTemplate->GetFunction(isolate->GetCurrentContext()).ToLocalChecked();
     Local<Object> callObject = function->NewInstance(isolate->GetCurrentContext()).ToLocalChecked();
     return callObject;
 }
diff --git a/src/node_ls2_call.h b/src/node_ls2_call.h
index 16fb738..405d64c 100644
--- a/src/node_ls2_call.h
+++ b/src/node_ls2_call.h
@@ -28,7 +28,7 @@ public:
     enum {kUnlimitedResponses = 0};
 
 	// Create the "Call" function template and add it to the target.
-	static void Initialize (v8::Handle<v8::Object> target);
+	static void Initialize (v8::Local<v8::Object> target);
 	
 	// Create a "Call" JavaScript object and with a handle and a token.
 	static v8::Local<v8::Object> NewForCall();
diff --git a/src/node_ls2_handle.cpp b/src/node_ls2_handle.cpp
index d9b94e3..e4c0e3b 100755
--- a/src/node_ls2_handle.cpp
+++ b/src/node_ls2_handle.cpp
@@ -46,7 +46,7 @@ static std::set<std::string> trustedScripts = {
 
 // Called during add-on initialization to add the "Handle" template function
 // to the target object.
-void LS2Handle::Initialize(Handle<Object> target)
+void LS2Handle::Initialize(Local<Object> target)
 {
     v8::Isolate* isolate = v8::Isolate::GetCurrent();
     HandleScope scope(isolate);
@@ -69,7 +69,7 @@ void LS2Handle::Initialize(Handle<Object> target)
     cancel_symbol.Reset(isolate, String::NewFromUtf8(isolate, "cancel"));
     request_symbol.Reset(isolate, String::NewFromUtf8(isolate, "request"));
 
-    target->Set(String::NewFromUtf8(isolate, "Handle"), t->GetFunction());
+    target->Set(String::NewFromUtf8(isolate, "Handle"), t->GetFunction(isolate->GetCurrentContext()).ToLocalChecked());
     NODE_SET_METHOD(target, "setAppId", LS2Handle::SetAppId);
 }
 
@@ -152,30 +152,30 @@ LS2Handle::~LS2Handle()
 
 void LS2Handle::CallWrapper(const v8::FunctionCallbackInfo<v8::Value>& args)
 {
-    MemberFunctionWrapper<LS2Handle, Handle<Value>, const char*, const char*>(&LS2Handle::Call, args);
+    MemberFunctionWrapper<LS2Handle, Local<Value>, const char*, const char*>(&LS2Handle::Call, args);
 }
 
-Handle<Value> LS2Handle::Call(const char* busName, const char* payload)
+Local<Value> LS2Handle::Call(const char* busName, const char* payload)
 {
     return CallInternal(busName, payload, 1);
 }
 
 void LS2Handle::WatchWrapper(const v8::FunctionCallbackInfo<v8::Value>& args)
 {
-    MemberFunctionWrapper<LS2Handle, Handle<Value>, const char*, const char*>(&LS2Handle::Watch, args);
+    MemberFunctionWrapper<LS2Handle, Local<Value>, const char*, const char*>(&LS2Handle::Watch, args);
 }
 
-Handle<Value> LS2Handle::Watch(const char* busName, const char* payload)
+Local<Value> LS2Handle::Watch(const char* busName, const char* payload)
 {
     return CallInternal(busName, payload, 2);
 }
 
 void LS2Handle::SubscribeWrapper(const v8::FunctionCallbackInfo<v8::Value>& args)
 {
-    MemberFunctionWrapper<LS2Handle, Handle<Value>, const char*, const char*>(&LS2Handle::Subscribe, args);
+    MemberFunctionWrapper<LS2Handle, Local<Value>, const char*, const char*>(&LS2Handle::Subscribe, args);
 }
 
-Handle<Value> LS2Handle::Subscribe(const char* busName, const char* payload)
+Local<Value> LS2Handle::Subscribe(const char* busName, const char* payload)
 {
     return CallInternal(busName, payload, LS2Call::kUnlimitedResponses);
 }
@@ -274,7 +274,7 @@ void LS2Handle::SubscriptionAdd(const char* key, LS2Message* msg)
     }
 }
 
-Handle<Value> LS2Handle::CallInternal(const char* busName, const char* payload, int responseLimit)
+Local<Value> LS2Handle::CallInternal(const char* busName, const char* payload, int responseLimit)
 {
     RequireHandle();
     Local<Object> callObject = LS2Call::NewForCall();
@@ -400,7 +400,7 @@ void LS2Handle::RequireHandle()
 void LS2Handle::checkCallerScriptPermissions(v8::Isolate* isolate)
 {
     Local<StackTrace> trace = StackTrace::CurrentStackTrace(isolate, 1, StackTrace::kScriptName);
-    ConvertFromJS<std::string> scriptName(trace->GetFrame(0)->GetScriptName());
+    ConvertFromJS<std::string> scriptName(trace->GetFrame(isolate, 0)->GetScriptName());
     if (!trustedScripts.count(scriptName.value())) {
         throw std::runtime_error("Incorrect execution context");
     }
@@ -410,8 +410,8 @@ const std::string& LS2Handle::findMyAppId(v8::Isolate* isolate)
 {
     v8::Local<v8::StackTrace> trace = v8::StackTrace::CurrentStackTrace(isolate, 50, v8::StackTrace::kScriptName);
     for(int i = 0; i < trace->GetFrameCount(); i++) {
-        std::string scriptName = ConvertFromJS<std::string>(trace->GetFrame(i)->GetScriptName()).value();
-        std::string scriptDirectory = scriptName.substr(0, scriptName.rfind('/'));
+        std::string scriptName = ConvertFromJS<std::string>(trace->GetFrame(isolate, i)->GetScriptName()).value();
+        std::string scriptDirectory = scriptName.substr(0, scriptName.rfind('/') + 1);
         auto serviceInfo = fRegisteredServices.find(scriptDirectory);
         if (serviceInfo != fRegisteredServices.end()) {
             return serviceInfo->second;
diff --git a/src/node_ls2_handle.h b/src/node_ls2_handle.h
index 586f792..0e27e78 100644
--- a/src/node_ls2_handle.h
+++ b/src/node_ls2_handle.h
@@ -32,7 +32,7 @@ class LS2Call;
 class LS2Handle : public LS2Base {
 public:
 	// Create the "Handle" function template and add it to the target.
-	static void Initialize (v8::Handle<v8::Object> target);
+	static void Initialize (v8::Local<v8::Object> target);
 
     void CallCreated(LS2Call* call);
     void CallCompleted(LS2Call* call);
@@ -51,13 +51,13 @@ private:
 	virtual ~LS2Handle();
 
 	static void CallWrapper(const v8::FunctionCallbackInfo<v8::Value>& args);
-	v8::Handle<v8::Value> Call(const char* busName, const char* payload);
+	v8::Local<v8::Value> Call(const char* busName, const char* payload);
 
 	static void WatchWrapper(const v8::FunctionCallbackInfo<v8::Value>& args);
-	v8::Handle<v8::Value> Watch(const char* busName, const char* payload);
+	v8::Local<v8::Value> Watch(const char* busName, const char* payload);
 
 	static void SubscribeWrapper(const v8::FunctionCallbackInfo<v8::Value>& args);
-	v8::Handle<v8::Value> Subscribe(const char* busName, const char* payload);
+	v8::Local<v8::Value> Subscribe(const char* busName, const char* payload);
 
 	static void CancelWrapper(const v8::FunctionCallbackInfo<v8::Value>& args);
 	bool Cancel(LSMessageToken token);
@@ -75,7 +75,7 @@ private:
 	void SubscriptionAdd(const char* key, LS2Message* msg);
 
 	// Common implmentation for Call, Watch and Subscribe
-   	v8::Handle<v8::Value> CallInternal(const char* busName, const char* payload, int responseLimit);
+   	v8::Local<v8::Value> CallInternal(const char* busName, const char* payload, int responseLimit);
 
    	// Glib integration
 	void Attach(GMainLoop *mainLoop);
@@ -94,7 +94,7 @@ private:
 	static const std::string& findMyAppId(v8::Isolate* isolate);
 	// Common routine called whenever a message arrives from the bus. Different symbols
 	// are used to differentiate requests, responses and cancelled subscriptions
-	//void EmitMessage(const v8::Handle<v8::String>& symbol, LSMessage *message);
+	//void EmitMessage(const v8::Local<v8::String>& symbol, LSMessage *message);
 
 	// Throws an exception if fHandle is 0.
 	void RequireHandle();
diff --git a/src/node_ls2_message.cpp b/src/node_ls2_message.cpp
index f8bca84..929f7c2 100644
--- a/src/node_ls2_message.cpp
+++ b/src/node_ls2_message.cpp
@@ -27,7 +27,7 @@ using namespace node;
 
 // Converter for LSMessage tokens. See node_ls2_utils.h for a description 
 // of how the conversion system works.
-template <> v8::Handle<v8::Value> ConvertToJS<LSMessageToken>(LSMessageToken v)
+template <> v8::Local<v8::Value> ConvertToJS<LSMessageToken>(LSMessageToken v)
 {
     return v8::Integer::NewFromUnsigned(v8::Isolate::GetCurrent(), v);
 }
@@ -38,7 +38,7 @@ Persistent<FunctionTemplate> LS2Message::gMessageTemplate;
 
 // Called during add-on initialization to add the "Message" template function
 // to the target object.
-void LS2Message::Initialize (Handle<Object> target)
+void LS2Message::Initialize (Local<Object> target)
 {
     v8::Isolate* isolate = v8::Isolate::GetCurrent();
     HandleScope scope(isolate);
@@ -65,7 +65,7 @@ void LS2Message::Initialize (Handle<Object> target)
     NODE_SET_PROTOTYPE_METHOD(t, "isSubscription", IsSubscriptionWrapper);
     NODE_SET_PROTOTYPE_METHOD(t, "respond", RespondWrapper);
 
-    target->Set(String::String::NewFromUtf8(isolate, "Message"), t->GetFunction());
+    target->Set(String::String::NewFromUtf8(isolate, "Message"), t->GetFunction(isolate->GetCurrentContext()).ToLocalChecked());
 }
 
 // Used by LSHandle to create a "Message" object that wraps a particular
@@ -76,7 +76,7 @@ Local<Value> LS2Message::NewFromMessage(LSMessage* message)
     
     TryCatch try_catch(isolate);
 
-    Local<Function> function = v8::Local<FunctionTemplate>::New(isolate, gMessageTemplate)->GetFunction();
+    Local<Function> function = v8::Local<FunctionTemplate>::New(isolate, gMessageTemplate)->GetFunction(isolate->GetCurrentContext()).ToLocalChecked();
     Local<Object> messageObject = function->NewInstance(isolate->GetCurrentContext()).ToLocalChecked();
 
     // If we get an exception in LS2Message::New, then it will return
@@ -93,7 +93,7 @@ Local<Value> LS2Message::NewFromMessage(LSMessage* message)
     } else {
         // We got an exception; If we try to continue we're going to lose
         // a message, so just crash
-        v8::String::Utf8Value exception(try_catch.Exception());
+        v8::String::Utf8Value exception(isolate, try_catch.Exception());
         syslog(LOG_USER | LOG_CRIT, "%s: exception: %s; aborting", __PRETTY_FUNCTION__, 
                                     *exception ? *exception : "no exception string");
         abort();
diff --git a/src/node_ls2_message.h b/src/node_ls2_message.h
index 383294a..0e085e0 100644
--- a/src/node_ls2_message.h
+++ b/src/node_ls2_message.h
@@ -31,7 +31,7 @@ struct LSMessage;
 class LS2Message : public node::ObjectWrap {
 public:
 	// Create the "Message" function template and add it to the target.
-	static void Initialize (v8::Handle<v8::Object> target);
+	static void Initialize (v8::Local<v8::Object> target);
 
 	// Create a "Message" JavaScript object and wrap it around the C++ LSMessage object.
 	static v8::Local<v8::Value> NewFromMessage(LSMessage*);
@@ -120,8 +120,8 @@ private:
 // object. See node_ls2_utils.h for a description of how ConvertFromJS works.
 
 template <> struct ConvertFromJS<LS2Message*> {
-    explicit ConvertFromJS(const v8::Handle<v8::Value>& value) : fMessage(0) {
-        v8::Handle<v8::Object> o = v8::Handle<v8::Object>::Cast(value);
+    explicit ConvertFromJS(const v8::Local<v8::Value>& value) : fMessage(0) {
+        v8::Local<v8::Object> o = v8::Local<v8::Object>::Cast(value);
         fMessage = node::ObjectWrap::Unwrap<LS2Message>(o);
         if (!fMessage) {
             throw std::runtime_error("Unable to unwrap native object.");
diff --git a/src/node_ls2_utils.cpp b/src/node_ls2_utils.cpp
index 6ef72a7..4615b1e 100644
--- a/src/node_ls2_utils.cpp
+++ b/src/node_ls2_utils.cpp
@@ -16,22 +16,22 @@
 
 #include "node_ls2_utils.h"
 
-template <> v8::Handle<v8::Value> ConvertToJS<const char*>(const char* v)
+template <> v8::Local<v8::Value> ConvertToJS<const char*>(const char* v)
 {
     return v8::String::NewFromUtf8(v8::Isolate::GetCurrent(), v);
 }
 
-template <> v8::Handle<v8::Value> ConvertToJS<uint32_t>(uint32_t v)
+template <> v8::Local<v8::Value> ConvertToJS<uint32_t>(uint32_t v)
 {
     return v8::Integer::NewFromUnsigned(v8::Isolate::GetCurrent(), v);
 }
 
-template <> v8::Handle<v8::Value> ConvertToJS<bool>(bool v)
+template <> v8::Local<v8::Value> ConvertToJS<bool>(bool v)
 {
     return v8::Boolean::New(v8::Isolate::GetCurrent(), v);
 }
 
-template <> v8::Handle<v8::Value> ConvertToJS< v8::Handle<v8::Value> >(v8::Handle<v8::Value>  v)
+template <> v8::Local<v8::Value> ConvertToJS< v8::Local<v8::Value> >(v8::Local<v8::Value>  v)
 {
     return v;
 }
diff --git a/src/node_ls2_utils.h b/src/node_ls2_utils.h
index 38aa4de..3878912 100644
--- a/src/node_ls2_utils.h
+++ b/src/node_ls2_utils.h
@@ -32,7 +32,7 @@
 // function, though, so there need to be specializations for each of the types that are used to
 // instantiate ConvertToJS. The more generic specializations are found in node_ls2_utils.cpp, others
 // are found in the source files where the type in question is used.
-template <typename T> v8::Handle<v8::Value> ConvertToJS(T v);
+template <typename T> v8::Local<v8::Value> ConvertToJS(T v);
 
 
 // This is a templated structure declaration for a structure that automatically converts a V8
@@ -43,12 +43,12 @@ template <typename T> v8::Handle<v8::Value> ConvertToJS(T v);
 // String::Utf8Value() structure to convert v8 strings to const char* reference. String::Utf8Value
 // cannot be copied, so we can't return it from a function.
 template <typename T> struct ConvertFromJS {
-	explicit ConvertFromJS(const v8::Handle<v8::Value>&);
+	explicit ConvertFromJS(const v8::Local<v8::Value>&);
 	T value() const;
 };
 
 template <> struct ConvertFromJS<const char*> {
-	explicit ConvertFromJS(const v8::Handle<v8::Value>& value) : isNull(value->IsNull() || value->IsUndefined()), fString(value) {}
+	explicit ConvertFromJS(const v8::Local<v8::Value>& value) : isNull(value->IsNull() || value->IsUndefined()), fString(v8::Isolate::GetCurrent(), value) {}
 	const char* value() const {
 		return isNull ? nullptr : *fString;
 	}
@@ -59,7 +59,7 @@ private:
 };
 
 template <> struct ConvertFromJS<std::string> {
-	explicit ConvertFromJS(const v8::Handle<v8::Value>& value) : isNull(value->IsNull() || value->IsUndefined()), fString(value) {}
+	explicit ConvertFromJS(const v8::Local<v8::Value>& value) : isNull(value->IsNull() || value->IsUndefined()), fString(v8::Isolate::GetCurrent(), value) {}
 	std::string value() const {
 		if (isNull) {
 			throw std::runtime_error("Null value but string expected");
@@ -72,7 +72,7 @@ private:
 };
 
 template <> struct ConvertFromJS<unsigned long> {
-	explicit ConvertFromJS(const v8::Handle<v8::Value>& value) : fValue(value->Uint32Value()) {}
+	explicit ConvertFromJS(const v8::Local<v8::Value>& value) : fValue(value->Uint32Value(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(0)) {}
 	unsigned long value() const {
 		return fValue;
 	}
@@ -81,7 +81,7 @@ template <> struct ConvertFromJS<unsigned long> {
 };
 
 template <> struct ConvertFromJS<int> {
-	explicit ConvertFromJS(const v8::Handle<v8::Value>& value) : fValue(value->Int32Value()) {}
+	explicit ConvertFromJS(const v8::Local<v8::Value>& value) : fValue(value->Int32Value(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(0)) {}
 	int value() const {
 		return fValue;
 	}
