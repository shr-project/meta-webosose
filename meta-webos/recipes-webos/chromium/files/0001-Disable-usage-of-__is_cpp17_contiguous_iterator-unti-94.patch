From 44f2b820fd6d3edcd263c1ce456eb5241daedb90 Mon Sep 17 00:00:00 2001
From: Daniel Cheng <dcheng@chromium.org>
Date: Tue, 30 May 2023 20:22:27 +0000
Subject: [PATCH] Disable usage of `__is_cpp17_contiguous_iterator` until
 libc++ rolls.

Though names prefixed with `__` are reserved for implementation use,
specializing `__is_cpp17_contiguous_iterator` is currently the only way
to tell libc++ that `memcpy()` can be safe to use with a custom
iterator.  Without this workaround, there are noticeable regressions,
e.g. when using std::copy() with spans of trivially copyable types (see
https://crbug.com/994174).

However, https://reviews.llvm.org/D150801 renames this template to
`__libcpp_is_contiguous_iterator`, which blocks rolling past this libc++
revision. As a workaround, temporarily forward declare and specialize
both variants.
`
In addition, C++20 provides an official way for a custom iterator to opt
into these types of optimizations, using `iterator_concept`, so also go
ahead and opt `CheckedContiguousIterator` into using this.

Bug: 1449299
Bug: b/284031070
Change-Id: If4e667fca8d1475ce5ced76b6072134686d12f4a
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/4570684
Commit-Queue: Daniel Cheng <dcheng@chromium.org>
Reviewed-by: Nico Weber <thakis@chromium.org>
Cr-Commit-Position: refs/heads/main@{#1150815}
---
Upstream-Status: Backport [116.0.5803.1 https://chromium-review.googlesource.com/c/chromium/src/+/4570684 AND Submitted in http://gpro.lge.com/c/webosose/chromium94/+/373211 Disable usage of `__is_cpp17_contiguous_iterator` until libc++ rolls. AND http://gpro.lge.com/c/webosose/chromium108/+/373222 Disable usage of `__is_cpp17_contiguous_iterator` until libc++ rolls. (master branch) AND http://gpro.lge.com/c/webosose/chromium108/+/373221 Disable usage of `__is_cpp17_contiguous_iterator` until libc++ rolls. (@pro branch)]

 src/base/containers/checked_iterators.h       | 45 ++++++++++---------
 .../containers/checked_iterators_unittest.cc  | 28 ++++++++----
 2 files changed, 44 insertions(+), 29 deletions(-)

diff --git a/src/base/containers/checked_iterators.h b/src/base/containers/checked_iterators.h
index 89a0d10b55..f74dd4a671 100644
--- a/src/base/containers/checked_iterators.h
+++ b/src/base/containers/checked_iterators.h
@@ -23,6 +23,9 @@ class CheckedContiguousIterator {
   using pointer = T*;
   using reference = T&;
   using iterator_category = std::random_access_iterator_tag;
+#if __cplusplus >= 202002L
+  using iterator_concept = std::contiguous_iterator_tag;
+#endif
 
   // Required for converting constructor below.
   template <typename U>
@@ -217,30 +220,33 @@ using CheckedContiguousConstIterator = CheckedContiguousIterator<const T>;
 
 }  // namespace base
 
-#if defined(_LIBCPP_VERSION) && !defined(OS_NACL)
-// Specialize both std::__is_cpp17_contiguous_iterator and std::pointer_traits
-// for CCI in case we compile with libc++ outside of NaCl. The former is
-// required to enable certain algorithm optimizations (e.g. std::copy can be a
-// simple std::memmove under certain circumstances), and is a precursor to
-// C++20's std::contiguous_iterator concept [1]. Once we actually use C++20 it
-// will be enough to add `using iterator_concept = std::contiguous_iterator_tag`
-// to the iterator class [2], and we can get rid of this non-standard
-// specialization.
-//
-// The latter is required to obtain the underlying raw pointer without resulting
-// in CHECK failures. The important bit is the `to_address(pointer)` overload,
-// which is the standard blessed way to customize `std::to_address(pointer)` in
-// C++20 [3].
-//
-// [1] https://wg21.link/iterator.concept.contiguous
-// [2] https://wg21.link/std.iterator.tags
-// [3] https://wg21.link/pointer.traits.optmem
-namespace std {
+#if defined(_LIBCPP_VERSION)
+
+// TODO(crbug.com/1284275): Remove when C++20 is on by default, as the use
+// of `iterator_concept` above should suffice.
+_LIBCPP_BEGIN_NAMESPACE_STD
+
+// TODO(crbug.com/1449299): https://reviews.llvm.org/D150801 renamed this from
+// `__is_cpp17_contiguous_iterator` to `__libcpp_is_contiguous_iterator`. Clean
+// up the old spelling after libc++ rolls.
+template <typename T>
+struct __is_cpp17_contiguous_iterator;
 
 template <typename T>
 struct __is_cpp17_contiguous_iterator<::base::CheckedContiguousIterator<T>>
     : true_type {};
 
+template <typename T>
+struct __libcpp_is_contiguous_iterator;
+template <typename T>
+struct __libcpp_is_contiguous_iterator<::base::CheckedContiguousIterator<T>>
+    : true_type {};
+
+_LIBCPP_END_NAMESPACE_STD
+#endif
+
+namespace std {
+
 template <typename T>
 struct pointer_traits<::base::CheckedContiguousIterator<T>> {
   using pointer = ::base::CheckedContiguousIterator<T>;
@@ -260,6 +266,5 @@ struct pointer_traits<::base::CheckedContiguousIterator<T>> {
 };
 
 }  // namespace std
-#endif
 
 #endif  // BASE_CONTAINERS_CHECKED_ITERATORS_H_
diff --git a/src/base/containers/checked_iterators_unittest.cc b/src/base/containers/checked_iterators_unittest.cc
index c7afe06b5c..67e925a1e4 100644
--- a/src/base/containers/checked_iterators_unittest.cc
+++ b/src/base/containers/checked_iterators_unittest.cc
@@ -84,11 +84,7 @@ TEST(CheckedContiguousIterator, ConvertingComparisonOperators) {
 
 }  // namespace base
 
-// ChromeOS does not use the in-tree libc++, but rather a shared library that
-// lags a bit behind.
-// TODO(crbug.com/1166360): Enable this test on ChromeOS once the shared libc++
-// is sufficiently modern.
-#if defined(_LIBCPP_VERSION) && !defined(OS_NACL) && !defined(OS_CHROMEOS)
+#if defined(_LIBCPP_VERSION)
 namespace {
 
 // Helper template that wraps an iterator and disables its dereference and
@@ -100,6 +96,8 @@ namespace {
 template <typename Iterator>
 struct DisableDerefAndIncr : Iterator {
   using Iterator::Iterator;
+
+  // NOLINTNEXTLINE(google-explicit-constructor)
   constexpr DisableDerefAndIncr(const Iterator& iter) : Iterator(iter) {}
 
   constexpr typename Iterator::reference operator*() {
@@ -120,16 +118,28 @@ struct DisableDerefAndIncr : Iterator {
 
 }  // namespace
 
-// Inherit `__is_cpp17_contiguous_iterator` and `pointer_traits` specializations
-// from the base class.
-namespace std {
+// Inherit `__libcpp_is_contiguous_iterator` and `pointer_traits`
+// specializations from the base class.
+
+// TODO(crbug.com/1284275): Remove when C++20 is on by default, as the use
+// of `iterator_concept` should suffice.
+_LIBCPP_BEGIN_NAMESPACE_STD
+
+// TODO(crbug.com/1449299): https://reviews.llvm.org/D150801 renamed this from
+// `__is_cpp17_contiguous_iterator` to `__libcpp_is_contiguous_iterator`. Clean
+// up the old spelling after libc++ rolls.
 template <typename Iter>
 struct __is_cpp17_contiguous_iterator<DisableDerefAndIncr<Iter>>
     : __is_cpp17_contiguous_iterator<Iter> {};
 
+template <typename Iter>
+struct __libcpp_is_contiguous_iterator<DisableDerefAndIncr<Iter>>
+    : __libcpp_is_contiguous_iterator<Iter> {};
+
 template <typename Iter>
 struct pointer_traits<DisableDerefAndIncr<Iter>> : pointer_traits<Iter> {};
-}  // namespace std
+
+_LIBCPP_END_NAMESPACE_STD
 
 namespace base {
 
